

def case(pred_fn_pairs, default=None, exclusive=False, strict=False, name='case'):
    'Create a case operation.\n\n  The `pred_fn_pairs` parameter is a dict or list of pairs of size N.\n  Each pair contains a boolean scalar tensor and a python callable that\n  creates the tensors to be returned if the boolean evaluates to True.\n  `default` is a callable generating a list of tensors. All the callables\n  in `pred_fn_pairs` as well as `default` (if provided) should return the same\n  number and types of tensors.\n\n  If `exclusive==True`, all predicates are evaluated, and an exception is\n  thrown if more than one of the predicates evaluates to `True`.\n  If `exclusive==False`, execution stops are the first predicate which\n  evaluates to True, and the tensors generated by the corresponding function\n  are returned immediately. If none of the predicates evaluate to True, this\n  operation returns the tensors generated by `default`.\n\n  `tf.case` supports nested structures as implemented in\n  `tensorflow.python.util.nest`. All of the callables must return the same\n  (possibly nested) value structure of lists, tuples, and/or named tuples.\n  Singleton lists and tuples form the only exceptions to this: when returned by\n  a callable, they are implicitly unpacked to single values. This\n  behavior is disabled by passing `strict=True`.\n\n  If an unordered dictionary is used for `pred_fn_pairs`, the order of the\n  conditional tests is not guaranteed. However, the order is guaranteed to be\n  deterministic, so that variables created in conditional branches are created\n  in fixed order across runs.\n\n  **Example 1:**\n\n  Pseudocode:\n\n  ```\n  if (x < y) return 17;\n  else return 23;\n  ```\n\n  Expressions:\n\n  ```python\n  f1 = lambda: tf.constant(17)\n  f2 = lambda: tf.constant(23)\n  r = case([(tf.less(x, y), f1)], default=f2)\n  ```\n\n  **Example 2:**\n\n  Pseudocode:\n\n  ```\n  if (x < y && x > z) raise OpError("Only one predicate may evaluate true");\n  if (x < y) return 17;\n  else if (x > z) return 23;\n  else return -1;\n  ```\n\n  Expressions:\n\n  ```python\n  def f1(): return tf.constant(17)\n  def f2(): return tf.constant(23)\n  def f3(): return tf.constant(-1)\n  r = case({tf.less(x, y): f1, tf.greater(x, z): f2},\n           default=f3, exclusive=True)\n  ```\n\n  Args:\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\n                   callable which returns a list of tensors.\n    default: Optional callable that returns a list of tensors.\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\n    strict: A boolean that enables/disables \'strict\' mode; see above.\n    name: A name for this operation (optional).\n\n  Returns:\n    The tensors returned by the first pair whose predicate evaluated to True, or\n    those returned by `default` if none does.\n\n  Raises:\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\n               callable.\n    ValueError: If in eager mode and all predicates are false and no\n               default is provided.\n    ValueError: If in eager mode and is passed a dictionary.\n  '
    pfp = pred_fn_pairs
    if (not (isinstance(pfp, list) or isinstance(pfp, _basetuple) or isinstance(pfp, dict))):
        raise TypeError('fns must be a list, tuple, or dict')
    if isinstance(pfp, dict):
        if context.in_eager_mode():
            raise ValueError('In eager mode the predicates must be a list, not a dictionary.')
        if isinstance(pfp, collections.OrderedDict):
            pfp = pfp.items()
        else:
            pfp = sorted(pfp.items(), key=(lambda item: item[0].name))
            if (not exclusive):
                logging.warn('%s: An unordered dictionary of predicate/fn pairs was provided, but exclusive=False. The order of conditional tests is deterministic but not guaranteed.', name)
    for tup in pfp:
        if ((not isinstance(tup, _basetuple)) or (len(tup) != 2)):
            raise TypeError('Each entry in pred_fn_pairs must be a 2-tuple')
        (pred, fn) = tup
        if (pred.dtype != dtypes.bool):
            raise TypeError('pred must be of type bool: %s', pred.name)
        if (not callable(fn)):
            raise TypeError(('fn for pred %s must be callable.' % pred.name))
    if ((default is not None) and (not callable(default))):
        raise TypeError('default must be callable.')
    if context.in_eager_mode():
        for (pred, fn) in pfp:
            if pred:
                return fn()
        if (default is None):
            raise ValueError('tf.case received all false predicates and no default.')
        return default()
    (preds, fns) = map(list, zip(*pfp))
    del pfp
    with ops.name_scope(name, 'case', [preds]):
        exclusivity_assert = (_assert_exclusive(preds) if exclusive else None)
        if (default is None):
            all_preds = _basetuple(preds)
            (last_pred, last_fn) = (preds.pop(), fns.pop())

            def new_default():
                preds_c = array_ops.stack(all_preds, name='preds_c')
                error_msg = [('None of the conditions evaluated as True. Conditions: (%s), Values:' % ', '.join([p.name for p in all_preds])), preds_c]
                assertion = Assert(condition=last_pred, data=error_msg, summarize=len(all_preds))
                with ops.control_dependencies([assertion]):
                    return last_fn()
            default = new_default
        if (not preds):
            return default()
        not_preds = []
        for (i, p) in enumerate(preds):
            with ops.name_scope(('not_%d' % i)):
                not_preds.append(math_ops.logical_not(p))
        and_not_preds = [constant_op.constant(True, name='always_true')]
        for (i, notp) in enumerate(not_preds):
            with ops.name_scope(('and_not_%d' % i)):
                and_not_preds.append(math_ops.logical_and(and_not_preds[(- 1)], notp))
        case_preds = []
        for (i, (p, and_not_p_prev)) in enumerate(zip(preds, and_not_preds[:(- 1)])):
            with ops.name_scope(('case_%d' % i)):
                case_preds.append(math_ops.logical_and(p, and_not_p_prev))
        with ops.name_scope('case_none_are_true'):
            case_preds.append(and_not_preds[(- 1)])
        with ops.name_scope('case_create_empty'):

            def _create_empty_constant(dtype, shape):
                value = ('' if (dtype == dtypes.string) else dtype.as_numpy_dtype())
                if (shape.ndims is None):
                    return array_ops.constant(value, dtype=dtype)
                else:
                    temp_shape = [(1 if (x.value is None) else x.value) for x in shape]
                    result = array_ops.constant(value, shape=temp_shape, dtype=dtype)
                    result._shape = shape
                    return result

            def _correct_empty(v):
                if isinstance(v, ops.Operation):
                    return no_op()
                elif isinstance(v, tensor_array_ops.TensorArray):
                    return v
                elif (not hasattr(v, 'dtype')):
                    return ops.convert_to_tensor(v)
                elif isinstance(v, sparse_tensor.SparseTensor):
                    return sparse_tensor.SparseTensor(indices=[([0] * len(v.get_shape()))], values=[v.dtype.as_numpy_dtype()], dense_shape=v.get_shape())
                else:
                    return _create_empty_constant(v.dtype, v.get_shape())
            empty = (lambda : nest.map_structure(_correct_empty, default()))

        def _build_case():
            all_fns = [fn for fn in fns]
            all_fns.append(default)
            prev_case = None
            for (i, (cp, fn)) in enumerate(list(zip(case_preds, all_fns))[::(- 1)]):
                prev_case = cond(cp, fn, (empty if (i == 0) else (lambda : prev_case)), strict=strict, name=('If_%d' % i))
            return prev_case
        if (exclusivity_assert is not None):
            with ops.control_dependencies([exclusivity_assert]):
                case_seq = _build_case()
        else:
            case_seq = _build_case()
        if (not strict):
            case_seq = _UnpackIfSingleton(case_seq)
        return case_seq
