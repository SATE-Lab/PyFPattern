

@keras_export('keras.experimental.export')
def export(model, saved_model_path, custom_objects=None, as_text=None, input_signature=None, serving_only=False):
    "Saves a `tf.keras.Model` into Tensorflow SavedModel format.\n\n  `save_model` generates new files/folders under the `saved_model_path` folder:\n  1) a checkpoint containing the model weights.\n  2) a saved_model.pb file containing the model's MetaGraphs. The prediction\n     graph is always exported. The evaluaton and training graphs are exported\n     if the following conditions are met:\n     - Evaluation: model loss is defined.\n     - Training: model is compiled with an optimizer defined under `tf.train`.\n       This is because `tf.keras.optimizers.Optimizer` instances cannot be\n       saved to checkpoints.\n  3) Model's json configuration, if model.get_config() has been implemented.\n     This file can be used to reload the model using\n     tf.keras.models.model_from_json(). Note that if any custom objects were\n     used, they should be passed to the `custom_object` argument when loading\n     the model.\n\n  Model limitations:\n  - Sequential and functional models can always be saved.\n  - Subclassed models can only be saved when `serving_only=True`. This is due to\n    the current implementation copying the model in order to export the training\n    and evaluation graphs. Because the topology of subclassed models cannot be\n    determined, the subclassed models cannot be cloned. Subclassed models will\n    be entirely exportable in the future.\n\n  Note that each mode is exported in separate graphs, so different modes do not\n  share variables. To use the train graph with evaluation or prediction graphs,\n  create a new checkpoint if variable values have been updated.\n\n  Example:\n\n  ```python\n  import tensorflow as tf\n\n  # Create a tf.keras model.\n  model = tf.keras.Sequential()\n  model.add(tf.keras.layers.Dense(1, input_shape=[10]))\n  model.summary()\n\n  # Save the tf.keras model in the SavedModel format.\n  saved_to_path = tf.keras.experimental.export(\n        model, '/tmp/my_simple_tf_keras_saved_model')\n\n  # Load the saved keras model back.\n  model_prime = tf.keras.experimental.load_from_saved_model(saved_to_path)\n  model_prime.summary()\n  ```\n\n  Args:\n    model: A `tf.keras.Model` to be saved. If the model is subclassed, the flag\n      `serving_only` must be set to True.\n    saved_model_path: a string specifying the path to the SavedModel directory.\n      The SavedModel will be saved to a timestamped folder created within this\n      directory.\n    custom_objects: Optional dictionary mapping string names to custom classes\n      or functions (e.g. custom loss functions).\n    as_text: whether to write the `SavedModel` proto in text format. Currently\n      unavailable in serving-only mode.\n    input_signature: A possibly nested sequence of `tf.TensorSpec` objects, used\n      to specify the expected model inputs. `input_signature`'s nested structure\n      should match the expected nested structure of the inputs to the model. If\n      this is not set, this function will attempt to infer the input shapes and\n      dtypes from the model. Note that if the model is subclassed, the tensor\n      inputs to the call function should be nested in the first argument (this\n      is a general requirement for using subclassed models with Keras functions\n      .fit(), .predict(), etc.).\n    serving_only: Export only the outputs produced from calling the model in\n      predict mode. The losses, optimizer, and other training configurations are\n      not saved. If the SavedModel will only be used for serving (rather than\n      retraining), or if the model is subclassed, this can be set to True.\n\n  Returns:\n    String path to the SavedModel folder, a subdirectory of `saved_model_path`.\n\n  Raises:\n    NotImplementedError: If the model is a subclassed model, and serving_only is\n      False.\n    ValueError: If the input signature cannot be inferred from the model.\n  "
    export_dir = model_utils.get_timestamped_export_dir(saved_model_path)
    if serving_only:
        save_lib.save(model, export_dir, signatures=saving_utils.trace_model_call(model, input_signature))
    else:
        _save_v1_format(model, export_dir, custom_objects, as_text, input_signature)
    try:
        _export_model_json(model, export_dir)
    except NotImplementedError:
        logging.warning('Skipped saving model JSON, subclassed model does not have get_config() defined.')
    return export_dir
