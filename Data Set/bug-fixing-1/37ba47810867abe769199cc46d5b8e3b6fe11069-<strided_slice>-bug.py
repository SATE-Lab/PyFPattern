

def strided_slice(input_, begin, end, strides=None, begin_mask=0, end_mask=0, ellipsis_mask=0, new_axis_mask=0, shrink_axis_mask=0, var=None, name=None):
    "Extracts a strided slice from a tensor.\n\n  To a first order, this operation extracts a slice of size `end - begin`\n  from a tensor `input`\n  starting at the location specified by `begin`. The slice continues by adding\n  `stride` to the `begin` index until all dimensions are not less than `end`.\n  Note that components of stride can be negative, which causes a reverse\n  slice.\n\n  This operation can be thought of an encoding of a numpy style sliced\n  range. Given a python slice input[<spec0>, <spec1>, ..., <specn>]\n  this function will be called as follows.\n\n  `begin`, `end`, and `strides` will be all length n. n is in general\n  not the same dimensionality as `input`.\n\n  For the ith spec,\n  `begin_mask`, `end_mask`, `ellipsis_mask`, `new_axis_mask`,\n  and `shrink_axis_mask` will have the ith bit corresponding to\n  the ith spec.\n\n  If the ith bit of `begin_mask` is non-zero, `begin[i]` is ignored and\n  the fullest possible range in that dimension is used instead.\n  `end_mask` works analogously, except with the end range.\n\n  `foo[5:,:,:3]` on a 7x8x9 tensor is equivalent to `foo[5:7,0:8,0:3]`.\n  `foo[::-1]` reverses a tensor with shape 8.\n\n\n  If the ith bit of `ellipsis_mask`, as many unspecified dimensions\n  as needed will be inserted between other dimensions. Only one\n  non-zero bit is allowed in `ellipsis_mask`.\n\n  For example `foo[3:5,...,4:5]` on a shape 10x3x3x10 tensor is\n  equivalent to `foo[3:5,:,:,4:5]` and\n  `foo[3:5,...]` is equivalent to `foo[3:5,:,:,:]`.\n\n  If the ith bit of `new_axis_mask` is one, then a `begin`,\n  `end`, and `stride` are ignored and a new length 1 dimension is\n  added at this point in the output tensor.\n\n  For example `foo[3:5,4]` on a 10x8 tensor produces a shape 2 tensor\n  whereas `foo[3:5,4:5]` produces a shape 2x1 tensor with shrink_mask\n  being 1<<1 == 2.\n\n  If the ith bit of `shrink_axis_mask` is one, then `begin`,\n  `end[i]`, and `stride[i]` are used to do a slice in the appropriate\n  dimension, but the output tensor will be reduced in dimensionality\n  by one. This is only valid if the ith entry of slice[i]==1.\n\n  NOTE: `begin` and `end` are zero-indexed`.\n  `strides` entries must be non-zero.\n\n\n  ```python\n  # 'input' is [[[1, 1, 1], [2, 2, 2]],\n  #             [[3, 3, 3], [4, 4, 4]],\n  #             [[5, 5, 5], [6, 6, 6]]]\n  tf.strided_slice(input, [1, 0, 0], [2, 1, 3], [1, 1, 1]) ==> [[[3, 3, 3]]]\n  tf.strided_slice(input, [1, 0, 0], [2, 2, 3], [1, 1, 1]) ==> [[[3, 3, 3],\n                                                                 [4, 4, 4]]]\n  tf.strided_slice(input, [1, 1, 0], [2, -1, 3], [1, -1, 1]) ==>[[[4, 4, 4],\n                                                                  [3, 3, 3]]]\n  ```\n\n  Args:\n    input_: A `Tensor`.\n    begin: An `int32` or `int64` `Tensor`.\n    end: An `int32` or `int64` `Tensor`.\n    strides: An `int32` or `int64` `Tensor`.\n    begin_mask: An `int32` mask.\n    end_mask: An `int32` mask.\n    ellipsis_mask: An `int32` mask.\n    new_axis_mask: An `int32` mask.\n    shrink_axis_mask: An `int32` mask.\n    var: The variable corresponding to `input_` or None\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` the same type as `input`.\n  "
    if (strides is None):
        strides = ones_like(begin)
    op = gen_array_ops.strided_slice(input=input_, begin=begin, end=end, strides=strides, name=name, begin_mask=begin_mask, end_mask=end_mask, ellipsis_mask=ellipsis_mask, new_axis_mask=new_axis_mask, shrink_axis_mask=shrink_axis_mask)

    def assign(val):
        'Closure that holds all the arguments to create an assignment.'
        if (var is None):
            raise ValueError('Sliced assignment is only supported for variables')
        return gen_array_ops.strided_slice_assign(ref=var, begin=begin, end=end, strides=strides, value=val, name=(name + '_assign'), begin_mask=begin_mask, end_mask=end_mask, ellipsis_mask=ellipsis_mask, new_axis_mask=new_axis_mask, shrink_axis_mask=shrink_axis_mask)
    op.assign = assign
    return op
