

def str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):
    "\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : analogous, but stricter, relying on re.match instead of re.search\n    Series.str.startswith : Test if the start of each string element matches a pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40','40.0','41','41.0','35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    "
    if regex:
        if (not case):
            flags |= re.IGNORECASE
        regex = re.compile(pat, flags=flags)
        if (regex.groups > 0):
            warnings.warn('This pattern has match groups. To actually get the groups, use str.extract.', UserWarning, stacklevel=3)
        f = (lambda x: bool(regex.search(x)))
    elif case:
        f = (lambda x: (pat in x))
    else:
        upper_pat = pat.upper()
        f = (lambda x: (upper_pat in x))
        uppered = _na_map((lambda x: x.upper()), arr)
        return _na_map(f, uppered, na, dtype=bool)
    return _na_map(f, arr, na, dtype=bool)
