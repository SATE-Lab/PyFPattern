

def cross_validate(estimator, X, y=None, groups=None, scoring=None, cv=None, n_jobs=1, verbose=0, fit_params=None, pre_dispatch='2*n_jobs', return_train_score=True):
    "Evaluate metric(s) by cross-validation and also record fit/score times.\n\n    Read more in the :ref:`User Guide <multimetric_cross_validation>`.\n\n    Parameters\n    ----------\n    estimator : estimator object implementing 'fit'\n        The object to use to fit the data.\n\n    X : array-like\n        The data to fit. Can be for example a list, or an array.\n\n    y : array-like, optional, default: None\n        The target variable to try to predict in the case of\n        supervised learning.\n\n    groups : array-like, with shape (n_samples,), optional\n        Group labels for the samples used while splitting the dataset into\n        train/test set.\n\n    scoring : string, callable, list/tuple, dict or None, default: None\n        A single string (see :ref:`scoring_parameter`) or a callable\n        (see :ref:`scoring`) to evaluate the predictions on the test set.\n\n        For evaluating multiple metrics, either give a list of (unique) strings\n        or a dict with names as keys and callables as values.\n\n        NOTE that when using custom scorers, each scorer should return a single\n        value. Metric functions returning a list/array of values can be wrapped\n        into multiple scorers that return one value each.\n\n        See :ref:`multimetric_grid_search` for an example.\n\n        If None, the estimator's default scorer (if available) is used.\n\n    cv : int, cross-validation generator or an iterable, optional\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n          - None, to use the default 3-fold cross validation,\n          - integer, to specify the number of folds in a `(Stratified)KFold`,\n          - An object to be used as a cross-validation generator.\n          - An iterable yielding train, test splits.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n    n_jobs : integer, optional\n        The number of CPUs to use to do the computation. -1 means\n        'all CPUs'.\n\n    verbose : integer, optional\n        The verbosity level.\n\n    fit_params : dict, optional\n        Parameters to pass to the fit method of the estimator.\n\n    pre_dispatch : int, or string, optional\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n            - None, in which case all the jobs are immediately\n              created and spawned. Use this for lightweight and\n              fast-running jobs, to avoid delays due to on-demand\n              spawning of the jobs\n\n            - An int, giving the exact number of total jobs that are\n              spawned\n\n            - A string, giving an expression as a function of n_jobs,\n              as in '2*n_jobs'\n\n    return_train_score : boolean, default True\n        Whether to include train scores in the return dict if ``scoring`` is\n        of multimetric type.\n\n    Returns\n    -------\n    scores : dict of float arrays of shape=(n_splits,)\n        Array of scores of the estimator for each run of the cross validation.\n\n        A dict of arrays containing the score/time arrays for each scorer is\n        returned. The possible keys for this ``dict`` are:\n\n            ``test_score``\n                The score array for test scores on each cv split.\n            ``train_score``\n                The score array for train scores on each cv split.\n                This is available only if ``return_train_score`` parameter\n                is ``True``.\n            ``fit_time``\n                The time for fitting the estimator on the train\n                set for each cv split.\n            ``score_time``\n                The time for scoring the estimator on the test set for each\n                cv split. (Note time for scoring on the train set is not\n                included even if ``return_train_score`` is set to ``True``\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_score\n    >>> from sklearn.metrics.scorer import make_scorer\n    >>> from sklearn.metrics import confusion_matrix\n    >>> from sklearn.svm import LinearSVC\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n\n    # single metric evaluation using cross_validate\n    >>> cv_results = cross_validate(lasso, X, y, return_train_score=False)\n    >>> sorted(cv_results.keys())                         # doctest: +ELLIPSIS\n    ['fit_time', 'score_time', 'test_score']\n    >>> cv_results['test_score']    # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    array([ 0.33...,  0.08...,  0.03...])\n\n    # Multiple metric evaluation using cross_validate\n    # (Please refer the ``scoring`` parameter doc for more information)\n    >>> scores = cross_validate(lasso, X, y,\n    ...                         scoring=('r2', 'neg_mean_squared_error'))\n    >>> print(scores['test_neg_mean_squared_error'])      # doctest: +ELLIPSIS\n    [-3635.5... -3573.3... -6114.7...]\n    >>> print(scores['train_r2'])                         # doctest: +ELLIPSIS\n    [ 0.28...  0.39...  0.22...]\n\n    See Also\n    ---------\n    :func:`sklearn.metrics.cross_val_score`:\n        Run cross-validation for single metric evaluation.\n\n    :func:`sklearn.metrics.make_scorer`:\n        Make a scorer from a performance metric or loss function.\n\n    "
    (X, y, groups) = indexable(X, y, groups)
    cv = check_cv(cv, y, classifier=is_classifier(estimator))
    (scorers, _) = _check_multimetric_scoring(estimator, scoring=scoring)
    parallel = Parallel(n_jobs=n_jobs, verbose=verbose, pre_dispatch=pre_dispatch)
    scores = parallel((delayed(_fit_and_score)(clone(estimator), X, y, scorers, train, test, verbose, None, fit_params, return_train_score=return_train_score, return_times=True) for (train, test) in cv.split(X, y, groups)))
    if return_train_score:
        (train_scores, test_scores, fit_times, score_times) = zip(*scores)
        train_scores = _aggregate_score_dicts(train_scores)
    else:
        (test_scores, fit_times, score_times) = zip(*scores)
    test_scores = _aggregate_score_dicts(test_scores)
    ret = dict()
    ret['fit_time'] = np.array(fit_times)
    ret['score_time'] = np.array(score_times)
    for name in scorers:
        ret[('test_%s' % name)] = np.array(test_scores[name])
        if return_train_score:
            ret[('train_%s' % name)] = np.array(train_scores[name])
    return ret
