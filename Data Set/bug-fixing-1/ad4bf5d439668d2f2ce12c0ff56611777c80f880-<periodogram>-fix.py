

def periodogram(x, fs=1.0, window='boxcar', nfft=None, detrend='constant', return_onesided=True, scaling='density', axis=(- 1)):
    "\n    Estimate power spectral density using a periodogram.\n\n    Parameters\n    ----------\n    x : array_like\n        Time series of measurement values\n    fs : float, optional\n        Sampling frequency of the `x` time series. Defaults to 1.0.\n    window : str or tuple or array_like, optional\n        Desired window to use. If `window` is a string or tuple, it is\n        passed to `get_window` to generate the window values, which are\n        DFT-even by default. See `get_window` for a list of windows and\n        required parameters. If `window` is array_like it will be used\n        directly as the window and its length must be nperseg. Defaults\n        to 'boxcar'.\n    nfft : int, optional\n        Length of the FFT used. If `None` the length of `x` will be\n        used.\n    detrend : str or function or `False`, optional\n        Specifies how to detrend each segment. If `detrend` is a\n        string, it is passed as the `type` argument to the `detrend`\n        function. If it is a function, it takes a segment and returns a\n        detrended segment. If `detrend` is `False`, no detrending is\n        done. Defaults to 'constant'.\n    return_onesided : bool, optional\n        If `True`, return a one-sided spectrum for real data. If\n        `False` return a two-sided spectrum. Note that for complex\n        data, a two-sided spectrum is always returned.\n    scaling : { 'density', 'spectrum' }, optional\n        Selects between computing the power spectral density ('density')\n        where `Pxx` has units of V**2/Hz and computing the power\n        spectrum ('spectrum') where `Pxx` has units of V**2, if `x`\n        is measured in V and `fs` is measured in Hz. Defaults to\n        'density'\n    axis : int, optional\n        Axis along which the periodogram is computed; the default is\n        over the last axis (i.e. ``axis=-1``).\n\n    Returns\n    -------\n    f : ndarray\n        Array of sample frequencies.\n    Pxx : ndarray\n        Power spectral density or power spectrum of `x`.\n\n    Notes\n    -----\n    .. versionadded:: 0.12.0\n\n    See Also\n    --------\n    welch: Estimate power spectral density using Welch's method\n    lombscargle: Lomb-Scargle periodogram for unevenly sampled data\n\n    Examples\n    --------\n    >>> from scipy import signal\n    >>> import matplotlib.pyplot as plt\n    >>> np.random.seed(1234)\n\n    Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by\n    0.001 V**2/Hz of white noise sampled at 10 kHz.\n\n    >>> fs = 10e3\n    >>> N = 1e5\n    >>> amp = 2*np.sqrt(2)\n    >>> freq = 1234.0\n    >>> noise_power = 0.001 * fs / 2\n    >>> time = np.arange(N) / fs\n    >>> x = amp*np.sin(2*np.pi*freq*time)\n    >>> x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)\n\n    Compute and plot the power spectral density.\n\n    >>> f, Pxx_den = signal.periodogram(x, fs)\n    >>> plt.semilogy(f, Pxx_den)\n    >>> plt.ylim([1e-7, 1e2])\n    >>> plt.xlabel('frequency [Hz]')\n    >>> plt.ylabel('PSD [V**2/Hz]')\n    >>> plt.show()\n\n    If we average the last half of the spectral density, to exclude the\n    peak, we can recover the noise power on the signal.\n\n    >>> np.mean(Pxx_den[25000:])\n    0.00099728892368242854\n\n    Now compute and plot the power spectrum.\n\n    >>> f, Pxx_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum')\n    >>> plt.figure()\n    >>> plt.semilogy(f, np.sqrt(Pxx_spec))\n    >>> plt.ylim([1e-4, 1e1])\n    >>> plt.xlabel('frequency [Hz]')\n    >>> plt.ylabel('Linear spectrum [V RMS]')\n    >>> plt.show()\n\n    The peak height in the power spectrum is an estimate of the RMS\n    amplitude.\n\n    >>> np.sqrt(Pxx_spec.max())\n    2.0077340678640727\n\n    "
    x = np.asarray(x)
    if (x.size == 0):
        return (np.empty(x.shape), np.empty(x.shape))
    if (window is None):
        window = 'boxcar'
    if (nfft is None):
        nperseg = x.shape[axis]
    elif (nfft == x.shape[axis]):
        nperseg = nfft
    elif (nfft > x.shape[axis]):
        nperseg = x.shape[axis]
    elif (nfft < x.shape[axis]):
        s = ([np.s_[:]] * len(x.shape))
        s[axis] = np.s_[:nfft]
        x = x[s]
        nperseg = nfft
        nfft = None
    return welch(x, fs, window, nperseg, 0, nfft, detrend, return_onesided, scaling, axis)
