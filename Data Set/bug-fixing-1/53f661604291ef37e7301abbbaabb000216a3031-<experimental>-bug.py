

def experimental(api_name):
    "Declares that user is using an experimental feature.\n\n    The developer of an API can mark it as *experimental* by calling\n    this function. When users call experimental APIs, :class:`FutureWarning`\n    is issued.\n    The presentation of :class:`FutureWarning` is disabled by setting\n    ``chainer.disable_experimental_warning`` to ``True``,\n    which is ``False`` by default.\n\n    The basic usage is to call it in the function or method we want to\n    mark as experimental along with the API name.\n\n    .. testsetup::\n\n        import sys\n        import warnings\n\n        warnings.simplefilter('always')\n\n        def wrapper(message, category, filename, lineno, file=None, line=None):\n            sys.stdout.write(warnings.formatwarning(\n                message, category, filename, lineno))\n\n        showwarning_orig = warnings.showwarning\n        warnings.showwarning = wrapper\n\n    .. testcleanup::\n\n        warnings.showwarning = showwarning_orig\n\n    .. testcode::\n\n        from chainer import utils\n\n        def f(x):\n            utils.experimental('chainer.foo.bar.f')\n            # concrete implementation of f follows\n\n        f(1)\n\n    .. testoutput::\n        :options: +ELLIPSIS, +NORMALIZE_WHITESPACE\n\n        ... FutureWarning: chainer.foo.bar.f is experimental. The interface can change in the future. ...\n\n    We can also make a whole class experimental. In that case,\n    we should call this function in its ``__init__`` method.\n\n    .. testcode::\n\n        class C():\n            def __init__(self):\n              utils.experimental('chainer.foo.C')\n\n        C()\n\n    .. testoutput::\n        :options: +ELLIPSIS, +NORMALIZE_WHITESPACE\n\n        ... FutureWarning: chainer.foo.C is experimental. The interface can change in the future. ...\n\n    If we want to mark ``__init__`` method only, rather than class itself,\n    it is recommended that we explicitly feed its API name.\n\n    .. testcode::\n\n        class D():\n            def __init__(self):\n                utils.experimental('D.__init__')\n\n        D()\n\n    .. testoutput::\n        :options: +ELLIPSIS, +NORMALIZE_WHITESPACE\n\n        ...  FutureWarning: D.__init__ is experimental. The interface can change in the future. ...\n\n    Currently, we do not have any sophisticated way to mark some usage of\n    non-experimental function as experimental.\n    But we can support such usage by explicitly branching it.\n\n    .. testcode::\n\n        def g(x, experimental_arg=None):\n            if experimental_arg is not None:\n                utils.experimental('experimental_arg of chainer.foo.g')\n\n    Args:\n        api_name(str): The name of an API marked as experimental.\n    "
    if (not chainer.disable_experimental_feature_warning):
        warnings.warn('{} is experimental. The interface can change in the future.'.format(api_name), FutureWarning)
