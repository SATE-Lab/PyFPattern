

def density_prior_box(input, image, densities=None, fixed_sizes=None, fixed_ratios=None, variance=[0.1, 0.1, 0.2, 0.2], clip=False, steps=[0.0, 0.0], offset=0.5, flatten_to_2d=False, name=None):
    '\n\n    This op generates density prior boxes for SSD(Single Shot MultiBox Detector) \n    algorithm. Each position of the input produce N prior boxes, N is \n    determined by the count of densities, fixed_sizes and fixed_ratios. \n    Boxes center at grid points around each input position is generated by \n    this operator, and the grid points is determined by densities and \n    the count of density prior box is determined by fixed_sizes and fixed_ratios. \n    Obviously, the number of fixed_sizes is equal to the number of densities.\n    \n    For densities_i in densities:\n    \n    .. math::\n\n        N\\_density_prior\\_box = SUM(N\\_fixed\\_ratios * densities\\_i^2)\n\n    N_density_prior_box is the number of density_prior_box and N_fixed_ratios is the number of fixed_ratios.\n\n    Parameters:\n       input(Variable): 4-D tensor(NCHW), the data type should be float32 of float64.\n       image(Variable): 4-D tensor(NCHW), the input image data of PriorBoxOp, the data type should be float32 or float64.\n            the layout is NCHW.\n       densities(list|tuple|None): The densities of generated density prior \n            boxes, this attribute should be a list or tuple of integers. \n            Default: None.\n       fixed_sizes(list|tuple|None): The fixed sizes of generated density\n            prior boxes, this attribute should a list or tuple of same \n            length with :attr:`densities`. Default: None.\n       fixed_ratios(list|tuple|None): The fixed ratios of generated density\n            prior boxes, if this attribute is not set and :attr:`densities`\n            and :attr:`fix_sizes` is set, :attr:`aspect_ratios` will be used\n            to generate density prior boxes.\n       variance(list|tuple): The variances to be encoded in density prior boxes.\n            Default:[0.1, 0.1, 0.2, 0.2].\n       clip(bool): Whether to clip out of boundary boxes. Default: False.\n       step(list|tuple): Prior boxes step across width and height, If\n            step[0] equals 0.0 or step[1] equals 0.0, the density prior boxes step across\n            height or weight of the input will be automatically calculated.\n            Default: [0., 0.]\n       offset(float): Prior boxes center offset. Default: 0.5\n       flatten_to_2d(bool): Whether to flatten output prior boxes and variance\n           to 2D shape, the second dim is 4. Default: False.\n       name(str, optional): The default value is None.  Normally there is no need for user to set this property.  For more information, please refer to :ref:`api_guide_Name`\n    \n    Returns:\n        Tuple: A tuple with two Variable (boxes, variances)\n\n        boxes: the output density prior boxes of PriorBox.\n        4-D tensor, the layout is [H, W, num_priors, 4] when flatten_to_2d is False.\n        2-D tensor, the layout is [H * W * num_priors, 4] when flatten_to_2d is True.\n        H is the height of input, W is the width of input, and num_priors is the total box count of each position of input.\n\n        variances: the expanded variances of PriorBox.\n        4-D tensor, the layout is [H, W, num_priors, 4] when flatten_to_2d is False.\n        2-D tensor, the layout is [H * W * num_priors, 4] when flatten_to_2d is True.\n        H is the height of input, W is the width of input, and num_priors is the total box count of each position of input.\n\n\n    Examples:\n\n        .. code-block:: python\n\n\t    #declarative mode\n\n\t    import paddle.fluid as fluid\n\t    import numpy as np\n\n\t    input = fluid.data(name="input", shape=[None,3,6,9])\n\t    image = fluid.data(name="image", shape=[None,3,9,12])\n\t    box, var = fluid.layers.density_prior_box(\n                 input=input,\n                 image=image,\n                 densities=[4, 2, 1],\n                 fixed_sizes=[32.0, 64.0, 128.0],\n                 fixed_ratios=[1.],\n                 clip=True,\n                 flatten_to_2d=True)\n\n\t    place = fluid.CPUPlace()\n\t    exe = fluid.Executor(place)\n\t    exe.run(fluid.default_startup_program())\n \n\t    # prepare a batch of data\n\t    input_data = np.random.rand(1,3,6,9).astype("float32")\n\t    image_data = np.random.rand(1,3,9,12).astype("float32")\n \n\t    box_out, var_out = exe.run(\n\t        fluid.default_main_program(),\n                feed={"input":input_data,\n\t              "image":image_data},\n                fetch_list=[box,var],\n                return_numpy=True)\n \n\t    print(mask_out.shape)\n\t    # (1134, 4)\n            print(z_out.shape)\n\t    # (1134, 4)\n\n\n\t    #imperative mode\n\t    import paddle.fluid.dygraph as dg\n\n\t    with dg.guard(place) as g:\n    \t\tinput = dg.to_variable(input_data)\n    \t\timage = dg.to_variable(image_data)\n    \t\tbox, var = fluid.layers.density_prior_box(\n\t\t    input=input,\n\t\t    image=image,\n\t\t    densities=[4, 2, 1],\n\t\t    fixed_sizes=[32.0, 64.0, 128.0],\n\t\t    fixed_ratios=[1.],\n\t\t    clip=True)\n\n    \t\tprint(box.shape)\n\t\t# [6L, 9L, 21L, 4L]\n\t\tprint(var.shape)\n\t\t# [6L, 9L, 21L, 4L]\n\n    '
    helper = LayerHelper('density_prior_box', **locals())
    dtype = helper.input_dtype()

    def _is_list_or_tuple_(data):
        return (isinstance(data, list) or isinstance(data, tuple))
    if (not _is_list_or_tuple_(densities)):
        raise TypeError('densities should be a list or a tuple or None.')
    if (not _is_list_or_tuple_(fixed_sizes)):
        raise TypeError('fixed_sizes should be a list or a tuple or None.')
    if (not _is_list_or_tuple_(fixed_ratios)):
        raise TypeError('fixed_ratios should be a list or a tuple or None.')
    if (len(densities) != len(fixed_sizes)):
        raise ValueError('densities and fixed_sizes length should be euqal.')
    if (not (_is_list_or_tuple_(steps) and (len(steps) == 2))):
        raise ValueError('steps should be a list or tuple ', 'with length 2, (step_width, step_height).')
    densities = list(map(int, densities))
    fixed_sizes = list(map(float, fixed_sizes))
    fixed_ratios = list(map(float, fixed_ratios))
    steps = list(map(float, steps))
    attrs = {
        'variances': variance,
        'clip': clip,
        'step_w': steps[0],
        'step_h': steps[1],
        'offset': offset,
        'densities': densities,
        'fixed_sizes': fixed_sizes,
        'fixed_ratios': fixed_ratios,
        'flatten_to_2d': flatten_to_2d,
    }
    box = helper.create_variable_for_type_inference(dtype)
    var = helper.create_variable_for_type_inference(dtype)
    helper.append_op(type='density_prior_box', inputs={
        'Input': input,
        'Image': image,
    }, outputs={
        'Boxes': box,
        'Variances': var,
    }, attrs=attrs)
    box.stop_gradient = True
    var.stop_gradient = True
    return (box, var)
