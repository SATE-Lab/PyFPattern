def _score_samples(self, X):
    'Opposite of the Local Outlier Factor of X.\n\n        It is the opposite as bigger is better, i.e. large values correspond\n        to inliers.\n\n        Only available for novelty detection (when novelty is set to True).\n        The argument X is supposed to contain *new data*: if X contains a\n        point from training, it considers the later in its own neighborhood.\n        Also, the samples in X are not considered in the neighborhood of any\n        point.\n        The score_samples on training data is available by considering the\n        the ``negative_outlier_factor_`` attribute.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            The query sample or samples to compute the Local Outlier Factor\n            w.r.t. the training samples.\n\n        Returns\n        -------\n        opposite_lof_scores : array, shape (n_samples,)\n            The opposite of the Local Outlier Factor of each input samples.\n            The lower, the more abnormal.\n        '
    check_is_fitted(self, ['offset_', 'negative_outlier_factor_', '_distances_fit_X_'])
    X = check_array(X, accept_sparse='csr')
    (distances_X, neighbors_indices_X) = self.kneighbors(X, n_neighbors=self.n_neighbors_)
    X_lrd = self._local_reachability_density(distances_X, neighbors_indices_X)
    lrd_ratios_array = (self._lrd[neighbors_indices_X] / X_lrd[:, np.newaxis])
    return (- np.mean(lrd_ratios_array, axis=1))