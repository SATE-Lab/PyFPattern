def background_gradient(self, cmap='PuBu', low=0, high=0, axis=0, subset=None, text_color_threshold=0.408):
    "\n        Color the background in a gradient according to\n        the data in each column (optionally row).\n\n        Requires matplotlib.\n\n        Parameters\n        ----------\n        cmap : str or colormap\n            Matplotlib colormap.\n        low : float\n            Compress the range by the low.\n        high : float\n            Compress the range by the high.\n        axis : {0 or 'index', 1 or 'columns', None}, default 0\n            Apply to each column (``axis=0`` or ``'index'``), to each row\n            (``axis=1`` or ``'columns'``), or to the entire DataFrame at once\n            with ``axis=None``.\n        subset : IndexSlice\n            A valid slice for ``data`` to limit the style application to.\n        text_color_threshold : float or int\n            Luminance threshold for determining text color. Facilitates text\n            visibility across varying background colors. From 0 to 1.\n            0 = all text is dark colored, 1 = all text is light colored.\n\n            .. versionadded:: 0.24.0\n\n        Returns\n        -------\n        self : Styler\n\n        Raises\n        ------\n        ValueError\n            If ``text_color_threshold`` is not a value from 0 to 1.\n\n        Notes\n        -----\n        Set ``text_color_threshold`` or tune ``low`` and ``high`` to keep the\n        text legible by not using the entire range of the color map. The range\n        of the data is extended by ``low * (x.max() - x.min())`` and ``high *\n        (x.max() - x.min())`` before normalizing.\n        "
    subset = _maybe_numeric_slice(self.data, subset)
    subset = _non_reducing_slice(subset)
    self.apply(self._background_gradient, cmap=cmap, subset=subset, axis=axis, low=low, high=high, text_color_threshold=text_color_threshold)
    return self