def binned_statistic_2d(x, y, values, statistic='mean', bins=10, range=None, expand_binnumbers=False):
    "\n    Compute a bidimensional binned statistic for one or more sets of data.\n\n    This is a generalization of a histogram2d function.  A histogram divides\n    the space into bins, and returns the count of the number of points in\n    each bin.  This function allows the computation of the sum, mean, median,\n    or other statistic of the values (or set of values) within each bin.\n\n    Parameters\n    ----------\n    x : (N,) array_like\n        A sequence of values to be binned along the first dimension.\n    y : (N,) array_like\n        A sequence of values to be binned along the second dimension.\n    values : (N,) array_like or list of (N,) array_like\n        The data on which the statistic will be computed.  This must be\n        the same shape as `x`, or a list of sequences - each with the same\n        shape as `x`.  If `values` is such a list, the statistic will be\n        computed on each independently.\n    statistic : string or callable, optional\n        The statistic to compute (default is 'mean').\n        The following statistics are available:\n\n          * 'mean' : compute the mean of values for points within each bin.\n            Empty bins will be represented by NaN.\n          * 'std' : compute the standard deviation within each bin. This \n            is implicitly calculated with ddof=0.\n          * 'median' : compute the median of values for points within each\n            bin. Empty bins will be represented by NaN.\n          * 'count' : compute the count of points within each bin.  This is\n            identical to an unweighted histogram.  `values` array is not\n            referenced.\n          * 'sum' : compute the sum of values for points within each bin.\n            This is identical to a weighted histogram.\n          * 'min' : compute the minimum of values for points within each bin.\n            Empty bins will be represented by NaN.\n          * 'max' : compute the maximum of values for point within each bin.\n            Empty bins will be represented by NaN.\n          * function : a user-defined function which takes a 1D array of\n            values, and outputs a single numerical statistic. This function\n            will be called on the values in each bin.  Empty bins will be\n            represented by function([]), or NaN if this returns an error.\n\n    bins : int or [int, int] or array_like or [array, array], optional\n        The bin specification:\n\n          * the number of bins for the two dimensions (nx = ny = bins),\n          * the number of bins in each dimension (nx, ny = bins),\n          * the bin edges for the two dimensions (x_edge = y_edge = bins),\n          * the bin edges in each dimension (x_edge, y_edge = bins).\n\n        If the bin edges are specified, the number of bins will be,\n        (nx = len(x_edge)-1, ny = len(y_edge)-1).\n\n    range : (2,2) array_like, optional\n        The leftmost and rightmost edges of the bins along each dimension\n        (if not specified explicitly in the `bins` parameters):\n        [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be\n        considered outliers and not tallied in the histogram.\n    expand_binnumbers : bool, optional\n        'False' (default): the returned `binnumber` is a shape (N,) array of\n        linearized bin indices.\n        'True': the returned `binnumber` is 'unraveled' into a shape (2,N)\n        ndarray, where each row gives the bin numbers in the corresponding\n        dimension.\n        See the `binnumber` returned value, and the `Examples` section.\n\n        .. versionadded:: 0.17.0\n\n    Returns\n    -------\n    statistic : (nx, ny) ndarray\n        The values of the selected statistic in each two-dimensional bin.\n    x_edge : (nx + 1) ndarray\n        The bin edges along the first dimension.\n    y_edge : (ny + 1) ndarray\n        The bin edges along the second dimension.\n    binnumber : (N,) array of ints or (2,N) ndarray of ints\n        This assigns to each element of `sample` an integer that represents the\n        bin in which this observation falls.  The representation depends on the\n        `expand_binnumbers` argument.  See `Notes` for details.\n\n\n    See Also\n    --------\n    numpy.digitize, numpy.histogram2d, binned_statistic, binned_statistic_dd\n\n    Notes\n    -----\n    Binedges:\n    All but the last (righthand-most) bin is half-open.  In other words, if\n    `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,\n    but excluding 2) and the second ``[2, 3)``.  The last bin, however, is\n    ``[3, 4]``, which *includes* 4.\n\n    `binnumber`:\n    This returned argument assigns to each element of `sample` an integer that\n    represents the bin in which it belongs.  The representation depends on the\n    `expand_binnumbers` argument. If 'False' (default): The returned\n    `binnumber` is a shape (N,) array of linearized indices mapping each\n    element of `sample` to its corresponding bin (using row-major ordering).\n    If 'True': The returned `binnumber` is a shape (2,N) ndarray where\n    each row indicates bin placements for each dimension respectively.  In each\n    dimension, a binnumber of `i` means the corresponding value is between\n    (D_edge[i-1], D_edge[i]), where 'D' is either 'x' or 'y'.\n\n    .. versionadded:: 0.11.0\n\n    Examples\n    --------\n    >>> from scipy import stats\n\n    Calculate the counts with explicit bin-edges:\n\n    >>> x = [0.1, 0.1, 0.1, 0.6]\n    >>> y = [2.1, 2.6, 2.1, 2.1]\n    >>> binx = [0.0, 0.5, 1.0]\n    >>> biny = [2.0, 2.5, 3.0]\n    >>> ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx,biny])\n    >>> ret.statistic\n    array([[ 2.,  1.],\n           [ 1.,  0.]])\n\n    The bin in which each sample is placed is given by the `binnumber`\n    returned parameter.  By default, these are the linearized bin indices:\n\n    >>> ret.binnumber\n    array([5, 6, 5, 9])\n\n    The bin indices can also be expanded into separate entries for each\n    dimension using the `expand_binnumbers` parameter:\n\n    >>> ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx,biny],\n    ...                                 expand_binnumbers=True)\n    >>> ret.binnumber\n    array([[1, 1, 1, 2],\n           [1, 2, 1, 1]])\n\n    Which shows that the first three elements belong in the xbin 1, and the\n    fourth into xbin 2; and so on for y.\n\n    "
    try:
        N = len(bins)
    except TypeError:
        N = 1
    if ((N != 1) and (N != 2)):
        xedges = yedges = np.asarray(bins, float)
        bins = [xedges, yedges]
    (medians, edges, binnumbers) = binned_statistic_dd([x, y], values, statistic, bins, range, expand_binnumbers=expand_binnumbers)
    return BinnedStatistic2dResult(medians, edges[0], edges[1], binnumbers)