@set_module('mxnet.symbol.numpy')
def outer(a, b):
    "Compute the outer product of two vectors.\n    Given two vectors, ``a = [a0, a1, ..., aM]`` and\n    ``b = [b0, b1, ..., bN]``,\n    the outer product [1]_ is::\n    [[a0*b0  a0*b1 ... a0*bN ]\n    [a1*b0    .\n    [ ...          .\n    [aM*b0            aM*bN ]]\n\n    Parameters\n    ----------\n    a : (M,) _Symbol\n        First input vector.  Input is flattened if\n        not already 1-dimensional.\n    b : (N,) _Symbol\n        Second input vector.  Input is flattened if\n        not already 1-dimensional.\n\n    Returns\n    -------\n    out : (M, N) _Symbol\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner\n    einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\n    ufunc.outer : A generalization to N dimensions and other operations.\n                ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.\n\n    References\n    ----------\n    .. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n            ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n            pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n        [-2., -1.,  0.,  1.,  2.],\n        [-2., -1.,  0.,  1.,  2.],\n        [-2., -1.,  0.,  1.,  2.],\n        [-2., -1.,  0.,  1.,  2.]])\n    "
    return tensordot(a.flatten(), b.flatten(), 0)