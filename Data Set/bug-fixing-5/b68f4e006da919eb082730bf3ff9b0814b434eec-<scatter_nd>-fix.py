def scatter_nd(index, updates, shape, name=None):
    "\n    **Scatter_nd Layer**\n\n    Output is obtained by scattering the :attr:`updates` in a new tensor according \n    to :attr:`index` . This op is similar to :code:`scatter_nd_add`, except the \n    tensor of :attr:`shape` is zero-initialized. Correspondingly, :code:`scatter_nd(index, updates, shape)` \n    is equal to :code:`scatter_nd_add(fluid.layers.zeros(shape, updates.dtype), index, updates)` . \n    If :attr:`index` has repeated elements, then the corresponding updates are accumulated. \n    Because of the numerical approximation issues, the different order of repeated elements \n    in :attr:`index` may cause different results. The specific calculation method can be \n    seen :code:`scatter_nd_add` . This op is the inverse of the :code:`gather_nd` op.\n\n    Args:\n        index (Variable): The index input with rank > 1 and index.shape[-1] <= len(shape).\n                          Its dtype should be int32 or int64 as it is used as indexes.\n        updates (Variable): The updated value of scatter_nd op. Its dtype should be float32, float64.\n                            It must have the shape index.shape[:-1] + shape[index.shape[-1]:]\n        shape(tuple|list): Shape of output tensor.\n        name (str|None): The output variable name. If set None, the layer will be named automatically.\n\n    Returns:\n        output (Variable): The output is a tensor with the same type as :attr:`updates` .\n\n    Examples:\n\n        .. code-block:: python\n\n            import paddle.fluid as fluid\n\n            index = fluid.data(name='index', shape=[3, 2], dtype='int64')\n            updates = fluid.data(name='update', shape=[3, 9, 10], dtype='float32')\n            shape = [3, 5, 9, 10]\n\n            output = fluid.layers.scatter_nd(index, updates, shape)\n    "
    return scatter_nd_add(zeros(shape, updates.dtype), index, updates, name)