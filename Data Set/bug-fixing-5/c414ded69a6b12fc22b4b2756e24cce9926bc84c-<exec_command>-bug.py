def exec_command(self, cmd):
    'Executes the cmd on in the shell and returns the output\n\n        The method accepts two forms of cmd.  The first form is as a\n        string that represents the command to be executed in the shell.  The\n        second form is as a JSON string with additional keyword.\n\n        Keywords supported for cmd:\n            * command - the command string to execute\n            * prompt - the expected prompt generated by executing command\n            * response - the string to respond to the prompt with\n\n        :arg cmd: the string that represents the command to be executed\n            which can be a single command or a json encoded string\n        :returns: a tuple of (return code, stdout, stderr).  The return\n            code is an integer and stdout and stderr are strings\n        '
    try:
        obj = json.loads(cmd)
    except ValueError:
        obj = {
            'command': str(cmd).strip(),
        }
    if (obj['command'] == 'close_shell()'):
        return self.close_shell()
    elif (obj['command'] == 'prompt()'):
        return (0, self._matched_prompt, '')
    elif (obj['command'] == 'history()'):
        return (0, self._history, '')
    try:
        if (self._shell is None):
            self.open_shell()
    except AnsibleConnectionFailure as exc:
        return (1, '', str(exc))
    try:
        out = self.send(obj)
        return (0, out, '')
    except (AnsibleConnectionFailure, ValueError) as exc:
        return (1, '', str(exc))