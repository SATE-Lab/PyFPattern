def ctc_beam_search_decoder(inputs, sequence_length, beam_width=100, top_paths=1, merge_repeated=True):
    'Performs beam search decoding on the logits given in input.\n\n  **Note** The `ctc_greedy_decoder` is a special case of the\n  `ctc_beam_search_decoder` with `top_paths=1` and `beam_width=1` (but\n  that decoder is faster for this special case).\n\n  If `merge_repeated` is `True`, merge repeated classes in the output beams.\n  This means that if consecutive entries in a beam are the same,\n  only the first of these is emitted.  That is, when the top path\n  is `A B B B B`, the return value is:\n\n    * `A B` if `merge_repeated = True`.\n    * `A B B B B` if `merge_repeated = False`.\n\n  Args:\n    inputs: 3-D `float` `Tensor`, size\n      `[max_time x batch_size x num_classes]`.  The logits.\n    sequence_length: 1-D `int32` vector containing sequence lengths,\n      having size `[batch_size]`.\n    beam_width: An int scalar >= 0 (beam search beam width).\n    top_paths: An int scalar >= 0, <= beam_width (controls output size).\n    merge_repeated: Boolean.  Default: True.\n\n  Returns:\n    A tuple `(decoded, log_probabilities)` where\n    decoded: A list of length top_paths, where `decoded[j]`\n      is a `SparseTensor` containing the decoded outputs:\n      `decoded[j].indices`: Indices matrix `(total_decoded_outputs[j] x 2)`\n        The rows store: [batch, time].\n      `decoded[j].values`: Values vector, size `(total_decoded_outputs[j])`.\n        The vector stores the decoded classes for beam j.\n      `decoded[j].shape`: Shape vector, size `(2)`.\n        The shape values are: `[batch_size, max_decoded_length[j]]`.\n    log_probability: A `float` matrix `(batch_size x top_paths)` containing\n        sequence log-probabilities.\n  '
    (decoded_ixs, decoded_vals, decoded_shapes, log_probabilities) = gen_ctc_ops._ctc_beam_search_decoder(inputs, sequence_length, beam_width=beam_width, top_paths=top_paths, merge_repeated=merge_repeated)
    return ([sparse_tensor.SparseTensor(ix, val, shape) for (ix, val, shape) in zip(decoded_ixs, decoded_vals, decoded_shapes)], log_probabilities)