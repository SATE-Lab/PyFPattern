def test_neighbors_badargs():
    assert_raises(ValueError, neighbors.NearestNeighbors, algorithm='blah')
    X = rng.random_sample((10, 2))
    Xsparse = csr_matrix(X)
    X3 = rng.random_sample((10, 3))
    y = np.ones(10)
    for cls in (neighbors.KNeighborsClassifier, neighbors.RadiusNeighborsClassifier, neighbors.KNeighborsRegressor, neighbors.RadiusNeighborsRegressor):
        assert_raises(ValueError, cls, weights='blah')
        assert_raises(ValueError, cls, p=(- 1))
        assert_raises(ValueError, cls, algorithm='blah')
        nbrs = cls(algorithm='ball_tree', metric='haversine')
        assert_raises(ValueError, nbrs.predict, X)
        assert_raises(ValueError, ignore_warnings(nbrs.fit), Xsparse, y)
        nbrs = cls(metric='haversine', algorithm='brute')
        nbrs.fit(X3, y)
        assert_raise_message(ValueError, 'Haversine distance only valid in 2 dimensions', nbrs.predict, X3)
        nbrs = cls()
        assert_raises(ValueError, nbrs.fit, np.ones((0, 2)), np.ones(0))
        assert_raises(ValueError, nbrs.fit, X[:, :, None], y)
        nbrs.fit(X, y)
        assert_raises(ValueError, nbrs.predict, [[]])
        if (isinstance(cls, neighbors.KNeighborsClassifier) or isinstance(cls, neighbors.KNeighborsRegressor)):
            nbrs = cls(n_neighbors=(- 1))
            assert_raises(ValueError, nbrs.fit, X, y)
    nbrs = neighbors.NearestNeighbors().fit(X)
    assert_raises(ValueError, nbrs.kneighbors_graph, X, mode='blah')
    assert_raises(ValueError, nbrs.radius_neighbors_graph, X, mode='blah')