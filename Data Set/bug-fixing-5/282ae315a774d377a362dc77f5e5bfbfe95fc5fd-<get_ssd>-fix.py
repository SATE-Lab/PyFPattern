def get_ssd(name, base_size, features, filters, sizes, ratios, steps, classes, dataset, pretrained=False, pretrained_base=True, ctx=mx.cpu(), root=os.path.join('~', '.mxnet', 'models'), **kwargs):
    'Get SSD models.\n\n    Parameters\n    ----------\n    name : str or None\n        Model name, if `None` is used, you must specify `features` to be a `HybridBlock`.\n    base_size : int\n        Base image size for training, this is fixed once training is assigned.\n        A fixed base size still allows you to have variable input size during test.\n    features : iterable of str or `HybridBlock`\n        List of network internal output names, in order to specify which layers are\n        used for predicting bbox values.\n        If `name` is `None`, `features` must be a `HybridBlock` which generate multiple\n        outputs for prediction.\n    filters : iterable of float or None\n        List of convolution layer channels which is going to be appended to the base\n        network feature extractor. If `name` is `None`, this is ignored.\n    sizes : iterable fo float\n        Sizes of anchor boxes, this should be a list of floats, in incremental order.\n        The length of `sizes` must be len(layers) + 1. For example, a two stage SSD\n        model can have ``sizes = [30, 60, 90]``, and it converts to `[30, 60]` and\n        `[60, 90]` for the two stages, respectively. For more details, please refer\n        to original paper.\n    ratios : iterable of list\n        Aspect ratios of anchors in each output layer. Its length must be equals\n        to the number of SSD output layers.\n    steps : list of int\n        Step size of anchor boxes in each output layer.\n    classes : iterable of str\n        Names of categories.\n    dataset : str\n        Name of dataset. This is used to identify model name because models trained on\n        different datasets are going to be very different.\n    pretrained : bool or str\n        Boolean value controls whether to load the default pretrained weights for model.\n        String value represents the hashtag for a certain version of pretrained weights.\n    pretrained_base : bool or str, optional, default is True\n        Load pretrained base network, the extra layers are randomized. Note that\n        if pretrained is `True`, this has no effect.\n    ctx : mxnet.Context\n        Context such as mx.cpu(), mx.gpu(0).\n    root : str\n        Model weights storing path.\n    norm_layer : object\n        Normalization layer used (default: :class:`mxnet.gluon.nn.BatchNorm`)\n        Can be :class:`mxnet.gluon.nn.BatchNorm` or :class:`mxnet.gluon.contrib.nn.SyncBatchNorm`.\n    norm_kwargs : dict\n        Additional `norm_layer` arguments, for example `num_devices=4`\n        for :class:`mxnet.gluon.contrib.nn.SyncBatchNorm`.\n\n    Returns\n    -------\n    HybridBlock\n        A SSD detection network.\n    '
    pretrained_base = (False if pretrained else pretrained_base)
    base_name = (None if callable(features) else name)
    net = SSD(base_name, base_size, features, filters, sizes, ratios, steps, pretrained=pretrained_base, classes=classes, ctx=ctx, root=root, **kwargs)
    if pretrained:
        from ..model_store import get_model_file
        full_name = '_'.join(('ssd', str(base_size), name, dataset))
        net.load_parameters(get_model_file(full_name, tag=pretrained, root=root), ctx=ctx)
    return net