def list_auxiliary_states(self):
    "Lists all the auxiliary states in the symbol.\n\n        Example usage:\n        ----------\n        >>> a = mx.sym.var('a')\n        >>> b = mx.sym.var('b')\n        >>> c = a + b\n        >>> c.list_auxiliary_states()\n        []\n\n        Example of auxiliary states in `BatchNorm`.\n        >>> data = mx.symbol.Variable('data')\n        >>> weight = mx.sym.Variable(name='fc1_weight')\n        >>> fc1  = mx.symbol.FullyConnected(data = data, weight=weight, name='fc1', num_hidden=128)\n        >>> fc2 = mx.symbol.BatchNorm(fc1, name='batchnorm0')\n        >>> fc2.list_auxiliary_states()\n        ['batchnorm0_moving_mean', 'batchnorm0_moving_var']\n\n        Returns\n        -------\n        aux_states : list of string\n            List of the auxiliary states in input symbol.\n\n        Notes\n        -----\n        Auxiliary states are special states of symbols that do not correspond to an argument,\n        and are not updated by gradient descent. Common examples of auxiliary states\n        include the `moving_mean` and `moving_variance` in `BatchNorm`.\n        Most operators do not have auxiliary states.\n        "
    size = ctypes.c_uint()
    sarr = ctypes.POINTER(ctypes.c_char_p)()
    check_call(_LIB.MXSymbolListAuxiliaryStates(self.handle, ctypes.byref(size), ctypes.byref(sarr)))
    return [py_str(sarr[i]) for i in range(size.value)]