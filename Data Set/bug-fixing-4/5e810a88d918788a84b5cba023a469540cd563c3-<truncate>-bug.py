def truncate(self: FrameOrSeries, before=None, after=None, axis=None, copy: bool_t=True) -> FrameOrSeries:
    '\n        Truncate a Series or DataFrame before and after some index value.\n\n        This is a useful shorthand for boolean indexing based on index\n        values above or below certain thresholds.\n\n        Parameters\n        ----------\n        before : date, str, int\n            Truncate all rows before this index value.\n        after : date, str, int\n            Truncate all rows after this index value.\n        axis : {0 or \'index\', 1 or \'columns\'}, optional\n            Axis to truncate. Truncates the index (rows) by default.\n        copy : bool, default is True,\n            Return a copy of the truncated section.\n\n        Returns\n        -------\n        type of caller\n            The truncated Series or DataFrame.\n\n        See Also\n        --------\n        DataFrame.loc : Select a subset of a DataFrame by label.\n        DataFrame.iloc : Select a subset of a DataFrame by position.\n\n        Notes\n        -----\n        If the index being truncated contains only datetime values,\n        `before` and `after` may be specified as strings instead of\n        Timestamps.\n\n        Examples\n        --------\n        >>> df = pd.DataFrame({\'A\': [\'a\', \'b\', \'c\', \'d\', \'e\'],\n        ...                    \'B\': [\'f\', \'g\', \'h\', \'i\', \'j\'],\n        ...                    \'C\': [\'k\', \'l\', \'m\', \'n\', \'o\']},\n        ...                    index=[1, 2, 3, 4, 5])\n        >>> df\n           A  B  C\n        1  a  f  k\n        2  b  g  l\n        3  c  h  m\n        4  d  i  n\n        5  e  j  o\n\n        >>> df.truncate(before=2, after=4)\n           A  B  C\n        2  b  g  l\n        3  c  h  m\n        4  d  i  n\n\n        The columns of a DataFrame can be truncated.\n\n        >>> df.truncate(before="A", after="B", axis="columns")\n           A  B\n        1  a  f\n        2  b  g\n        3  c  h\n        4  d  i\n        5  e  j\n\n        For Series, only rows can be truncated.\n\n        >>> df[\'A\'].truncate(before=2, after=4)\n        2    b\n        3    c\n        4    d\n        Name: A, dtype: object\n\n        The index values in ``truncate`` can be datetimes or string\n        dates.\n\n        >>> dates = pd.date_range(\'2016-01-01\', \'2016-02-01\', freq=\'s\')\n        >>> df = pd.DataFrame(index=dates, data={\'A\': 1})\n        >>> df.tail()\n                             A\n        2016-01-31 23:59:56  1\n        2016-01-31 23:59:57  1\n        2016-01-31 23:59:58  1\n        2016-01-31 23:59:59  1\n        2016-02-01 00:00:00  1\n\n        >>> df.truncate(before=pd.Timestamp(\'2016-01-05\'),\n        ...             after=pd.Timestamp(\'2016-01-10\')).tail()\n                             A\n        2016-01-09 23:59:56  1\n        2016-01-09 23:59:57  1\n        2016-01-09 23:59:58  1\n        2016-01-09 23:59:59  1\n        2016-01-10 00:00:00  1\n\n        Because the index is a DatetimeIndex containing only dates, we can\n        specify `before` and `after` as strings. They will be coerced to\n        Timestamps before truncation.\n\n        >>> df.truncate(\'2016-01-05\', \'2016-01-10\').tail()\n                             A\n        2016-01-09 23:59:56  1\n        2016-01-09 23:59:57  1\n        2016-01-09 23:59:58  1\n        2016-01-09 23:59:59  1\n        2016-01-10 00:00:00  1\n\n        Note that ``truncate`` assumes a 0 value for any unspecified time\n        component (midnight). This differs from partial string slicing, which\n        returns any partially matching dates.\n\n        >>> df.loc[\'2016-01-05\':\'2016-01-10\', :].tail()\n                             A\n        2016-01-10 23:59:55  1\n        2016-01-10 23:59:56  1\n        2016-01-10 23:59:57  1\n        2016-01-10 23:59:58  1\n        2016-01-10 23:59:59  1\n        '
    if (axis is None):
        axis = self._stat_axis_number
    axis = self._get_axis_number(axis)
    ax = self._get_axis(axis)
    if ((not ax.is_monotonic_increasing) and (not ax.is_monotonic_decreasing)):
        raise ValueError('truncate requires a sorted index')
    if ax.is_all_dates:
        from pandas.core.tools.datetimes import to_datetime
        before = to_datetime(before)
        after = to_datetime(after)
    if ((before is not None) and (after is not None)):
        if (before > after):
            raise ValueError(f'Truncate: {after} must be after {before}')
    slicer = ([slice(None, None)] * self._AXIS_LEN)
    slicer[axis] = slice(before, after)
    result = self.loc[tuple(slicer)]
    if isinstance(ax, MultiIndex):
        setattr(result, self._get_axis_name(axis), ax.truncate(before, after))
    if copy:
        result = result.copy()
    return result