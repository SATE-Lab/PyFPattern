@tf_export('scatter_add')
def scatter_add(ref, indices, updates, use_locking=False, name=None):
    'Adds sparse updates to the variable referenced by `resource`.\n\n  This operation computes\n\n  ```python\n      # Scalar indices\n      ref[indices, ...] += updates[...]\n\n      # Vector indices (for each i)\n      ref[indices[i], ...] += updates[i, ...]\n\n      # High rank indices (for each i, ..., j)\n      ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n  ```\n\n  This operation outputs `ref` after the update is done.\n  This makes it easier to chain operations that need to use the updated value.\n  Duplicate entries are handled correctly: if multiple `indices` reference\n  the same location, their contributions add.\n\n  Requires `updates.shape = indices.shape + ref.shape[1:]`.\n\n  <div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">\n  <img style="width:100%" src=\'https://www.tensorflow.org/images/ScatterAdd.png\' alt>\n  </div>\n\n  Args:\n    ref: A `Variable`.\n    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.\n      A tensor of indices into the first dimension of `ref`.\n    updates: A `Tensor`. Must have the same type as `ref`.\n      A tensor of updated values to store in `ref`.\n    use_locking: An optional `bool`. Defaults to `True`.\n      If True, the assignment will be protected by a lock;\n      otherwise the behavior is undefined, but may exhibit less contention.\n    name: A name for the operation (optional).\n\n  Returns:\n    Same as `ref`.  Returned as a convenience for operations that want\n    to use the updated values after the update is done.\n  '
    if ref.dtype._is_ref_dtype:
        return gen_state_ops.scatter_add(ref, indices, updates, use_locking=use_locking, name=name)
    return ref._lazy_read(gen_resource_variable_ops.resource_scatter_add(ref.handle, indices, ops.convert_to_tensor(updates, ref.dtype), name=name))