@array_function_dispatch(_ipmt_dispatcher)
def ipmt(rate, per, nper, pv, fv=0, when='end'):
    "\n    Compute the interest portion of a payment.\n\n    .. deprecated:: 1.18\n\n       `ipmt` is deprecated; see NEP 32::\n\n           https://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n        Use the corresponding function in the numpy-financial library,\n        https://pypi.org/project/numpy-financial\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    per : scalar or array_like of shape(M, )\n        Interest paid against the loan changes during the life or the loan.\n        The `per` is the payment period to calculate the interest amount.\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pv : scalar or array_like of shape(M, )\n        Present value\n    fv : scalar or array_like of shape(M, ), optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Interest portion of payment.  If all input is scalar, returns a scalar\n        float.  If any input is array_like, returns interest payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    See Also\n    --------\n    ppmt, pmt, pv\n\n    Notes\n    -----\n    The total payment is made up of payment against principal plus interest.\n\n    ``pmt = ppmt + ipmt``\n\n    Examples\n    --------\n    What is the amortization schedule for a 1 year loan of $2500 at\n    8.24% interest per year compounded monthly?\n\n    >>> principal = 2500.00\n\n    The 'per' variable represents the periods of the loan.  Remember that\n    financial equations start the period count at 1!\n\n    >>> per = np.arange(1*12) + 1\n    >>> ipmt = np.ipmt(0.0824/12, per, 1*12, principal)\n    >>> ppmt = np.ppmt(0.0824/12, per, 1*12, principal)\n\n    Each element of the sum of the 'ipmt' and 'ppmt' arrays should equal\n    'pmt'.\n\n    >>> pmt = np.pmt(0.0824/12, 1*12, principal)\n    >>> np.allclose(ipmt + ppmt, pmt)\n    True\n\n    >>> fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'\n    >>> for payment in per:\n    ...     index = payment - 1\n    ...     principal = principal + ppmt[index]\n    ...     print(fmt.format(payment, ppmt[index], ipmt[index], principal))\n     1  -200.58   -17.17  2299.42\n     2  -201.96   -15.79  2097.46\n     3  -203.35   -14.40  1894.11\n     4  -204.74   -13.01  1689.37\n     5  -206.15   -11.60  1483.22\n     6  -207.56   -10.18  1275.66\n     7  -208.99    -8.76  1066.67\n     8  -210.42    -7.32   856.25\n     9  -211.87    -5.88   644.38\n    10  -213.32    -4.42   431.05\n    11  -214.79    -2.96   216.26\n    12  -216.26    -1.49    -0.00\n\n    >>> interestpd = np.sum(ipmt)\n    >>> np.round(interestpd, 2)\n    -112.98\n\n    "
    when = _convert_when(when)
    (rate, per, nper, pv, fv, when) = np.broadcast_arrays(rate, per, nper, pv, fv, when)
    total_pmt = pmt(rate, nper, pv, fv, when)
    ipmt = (_rbl(rate, per, total_pmt, pv, when) * rate)
    try:
        ipmt = np.where((when == 1), (ipmt / (1 + rate)), ipmt)
        ipmt = np.where(np.logical_and((when == 1), (per == 1)), 0, ipmt)
    except IndexError:
        pass
    return ipmt