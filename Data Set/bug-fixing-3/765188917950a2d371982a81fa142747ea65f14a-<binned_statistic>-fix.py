def binned_statistic(x, values, statistic='mean', bins=10, range=None):
    "\n    Compute a binned statistic for one or more sets of data.\n\n    This is a generalization of a histogram function.  A histogram divides\n    the space into bins, and returns the count of the number of points in\n    each bin.  This function allows the computation of the sum, mean, median,\n    or other statistic of the values (or set of values) within each bin.\n\n    Parameters\n    ----------\n    x : (N,) array_like\n        A sequence of values to be binned.\n    values : (N,) array_like or list of (N,) array_like\n        The data on which the statistic will be computed.  This must be\n        the same shape as `x`, or a set of sequences - each the same shape as\n        `x`.  If `values` is a set of sequences, the statistic will be computed\n        on each independently.\n    statistic : string or callable, optional\n        The statistic to compute (default is 'mean').\n        The following statistics are available:\n\n          * 'mean' : compute the mean of values for points within each bin.\n            Empty bins will be represented by NaN.\n          * 'std' : compute the standard deviation within each bin. This\n            is implicitly calculated with ddof=0.\n          * 'median' : compute the median of values for points within each\n            bin. Empty bins will be represented by NaN.\n          * 'count' : compute the count of points within each bin.  This is\n            identical to an unweighted histogram.  `values` array is not\n            referenced.\n          * 'sum' : compute the sum of values for points within each bin.\n            This is identical to a weighted histogram.\n          * 'min' : compute the minimum of values for points within each bin.\n            Empty bins will be represented by NaN.\n          * 'max' : compute the maximum of values for point within each bin.\n            Empty bins will be represented by NaN.\n          * function : a user-defined function which takes a 1D array of\n            values, and outputs a single numerical statistic. This function\n            will be called on the values in each bin.  Empty bins will be\n            represented by function([]), or NaN if this returns an error.\n\n    bins : int or sequence of scalars, optional\n        If `bins` is an int, it defines the number of equal-width bins in the\n        given range (10 by default).  If `bins` is a sequence, it defines the\n        bin edges, including the rightmost edge, allowing for non-uniform bin\n        widths.  Values in `x` that are smaller than lowest bin edge are\n        assigned to bin number 0, values beyond the highest bin are assigned to\n        ``bins[-1]``.  If the bin edges are specified, the number of bins will\n        be, (nx = len(bins)-1).\n    range : (float, float) or [(float, float)], optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(x.min(), x.max())``.  Values outside the range are\n        ignored.\n\n    Returns\n    -------\n    statistic : array\n        The values of the selected statistic in each bin.\n    bin_edges : array of dtype float\n        Return the bin edges ``(length(statistic)+1)``.\n    binnumber: 1-D ndarray of ints\n        Indices of the bins (corresponding to `bin_edges`) in which each value\n        of `x` belongs.  Same length as `values`.  A binnumber of `i` means the\n        corresponding value is between (bin_edges[i-1], bin_edges[i]).\n\n    See Also\n    --------\n    numpy.digitize, numpy.histogram, binned_statistic_2d, binned_statistic_dd\n\n    Notes\n    -----\n    All but the last (righthand-most) bin is half-open.  In other words, if\n    `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,\n    but excluding 2) and the second ``[2, 3)``.  The last bin, however, is\n    ``[3, 4]``, which *includes* 4.\n\n    .. versionadded:: 0.11.0\n\n    Examples\n    --------\n    >>> from scipy import stats\n    >>> import matplotlib.pyplot as plt\n\n    First some basic examples:\n\n    Create two evenly spaced bins in the range of the given sample, and sum the\n    corresponding values in each of those bins:\n\n    >>> values = [1.0, 1.0, 2.0, 1.5, 3.0]\n    >>> stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)\n    (array([ 4. ,  4.5]), array([ 1.,  4.,  7.]), array([1, 1, 1, 2, 2]))\n\n    Multiple arrays of values can also be passed.  The statistic is calculated\n    on each set independently:\n\n    >>> values = [[1.0, 1.0, 2.0, 1.5, 3.0], [2.0, 2.0, 4.0, 3.0, 6.0]]\n    >>> stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)\n    (array([[ 4. ,  4.5], [ 8. ,  9. ]]), array([ 1.,  4.,  7.]),\n        array([1, 1, 1, 2, 2]))\n\n    >>> stats.binned_statistic([1, 2, 1, 2, 4], np.arange(5), statistic='mean',\n    ...                        bins=3)\n    (array([ 1.,  2.,  4.]), array([ 1.,  2.,  3.,  4.]),\n        array([1, 2, 1, 2, 3]))\n\n    As a second example, we now generate some random data of sailing boat speed\n    as a function of wind speed, and then determine how fast our boat is for\n    certain wind speeds:\n\n    >>> windspeed = 8 * np.random.rand(500)\n    >>> boatspeed = .3 * windspeed**.5 + .2 * np.random.rand(500)\n    >>> bin_means, bin_edges, binnumber = stats.binned_statistic(windspeed,\n    ...                 boatspeed, statistic='median', bins=[1,2,3,4,5,6,7])\n    >>> plt.figure()\n    >>> plt.plot(windspeed, boatspeed, 'b.', label='raw data')\n    >>> plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=5,\n    ...            label='binned statistic of data')\n    >>> plt.legend()\n\n    Now we can use ``binnumber`` to select all datapoints with a windspeed\n    below 1:\n\n    >>> low_boatspeed = boatspeed[binnumber == 0]\n\n    As a final example, we will use ``bin_edges`` and ``binnumber`` to make a\n    plot of a distribution that shows the mean and distribution around that\n    mean per bin, on top of a regular histogram and the probability\n    distribution function:\n\n    >>> x = np.linspace(0, 5, num=500)\n    >>> x_pdf = stats.maxwell.pdf(x)\n    >>> samples = stats.maxwell.rvs(size=10000)\n\n    >>> bin_means, bin_edges, binnumber = stats.binned_statistic(x, x_pdf,\n    ...         statistic='mean', bins=25)\n    >>> bin_width = (bin_edges[1] - bin_edges[0])\n    >>> bin_centers = bin_edges[1:] - bin_width/2\n\n    >>> plt.figure()\n    >>> plt.hist(samples, bins=50, density=True, histtype='stepfilled',\n    ...          alpha=0.2, label='histogram of data')\n    >>> plt.plot(x, x_pdf, 'r-', label='analytical pdf')\n    >>> plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=2,\n    ...            label='binned statistic of data')\n    >>> plt.plot((binnumber - 0.5) * bin_width, x_pdf, 'g.', alpha=0.5)\n    >>> plt.legend(fontsize=10)\n    >>> plt.show()\n\n    "
    try:
        N = len(bins)
    except TypeError:
        N = 1
    if (N != 1):
        bins = [np.asarray(bins, float)]
    if (range is not None):
        if (len(range) == 2):
            range = [range]
    (medians, edges, binnumbers) = binned_statistic_dd([x], values, statistic, bins, range)
    return BinnedStatisticResult(medians, edges[0], binnumbers)